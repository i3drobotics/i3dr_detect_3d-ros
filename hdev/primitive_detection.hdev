<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="13.0.2">
<procedure name="main">
<interface/>
<body>
<c>*** This script does the following </c>
<c>*** 1) Reads in a pointcloud</c>
<c>*** 2) Detects a plane</c>
<c>*** 3) Removes the plane from the orignal pointcloud</c>
<c>*** 4) Performs a primitive detection on the remaining points in the pointcloud</c>
<c>*** 5) Displays the detected cylinder in the original pointcloud</c>
<c></c>
<c>*** Global variables used for passing data in/out of script when working with ROS</c>
<c>** Filepath to input point cloud</c>
<l>global tuple GlobalInputPointCloudFilepath</l>
<l>global tuple GlobalOutputObjectPosition</l>
<c></c>
<c>*** Useful for locally testing detection uses files rather than variables</c>
<l>localTesting := false</l>
<l>testPointCloudFilepath := '../../../data/point_clouds/ball001.ply'</l>
<c></c>
<c>*** Define point cloud filepath</c>
<l>if (localTesting)</l>
<l>    pointCloudFilepath := testPointCloudFilepath</l>
<l>else</l>
<l>    pointCloudFilepath := GlobalInputPointCloudFilepath</l>
<l>endif</l>
<c></c>
<c>*** Step 1) Read in pointcloud</c>
<c></c>
<l>read_object_model_3d (pointCloudFilepath, 'm', [], [], ObjectModel3D, Status)</l>
<c></c>
<c>*** Step 2) Detects a plane in the pointcloud</c>
<c></c>
<l>fit_primitives_object_model_3d (ObjectModel3D, 'primitive_type', 'plane', ObjectModel3DPlane)</l>
<c></c>
<c>** Step 2b) determine parameters of the detected plane and produce a 3D model of the plane</c>
<c></c>
<l>get_object_model_3d_params (ObjectModel3DPlane, 'primitive_parameter_pose', PosePlane)</l>
<l>gen_plane_object_model_3d (PosePlane, [], [], ObjectModel3DPlaneNB)</l>
<c></c>
<c></c>
<c>*** Step 3) Remove plane</c>
<c>** Step 3a) Compare the distances between the two models</c>
<l>distance_object_model_3d (ObjectModel3D, ObjectModel3DPlaneNB, [], 0, ['signed_distances', 'distance_to'], ['true', 'primitive'])</l>
<l>get_object_model_3d_params (ObjectModel3D, '&amp;distance', DistancePlane)</l>
<c></c>
<c></c>
<l>tuple_min (DistancePlane, MinPlane)</l>
<l>tuple_max (DistancePlane, MaxPlane)</l>
<c></c>
<c>** Step 3b) Only select points above the plane</c>
<l>select_points_object_model_3d (ObjectModel3D, '&amp;distance', -MinPlane, MaxPlane, ObjectModel3DThresholded)</l>
<c></c>
<c></c>
<c></c>
<c>*** Step 4) Perform primitive detection on the remaining object</c>
<l>connection_object_model_3d (ObjectModel3DThresholded, 'distance_3d', 0.01, ObjectModel3DConnected)</l>
<l>select_object_model_3d (ObjectModel3DConnected, 'num_points', 'and',10000 , 500000, ObjectModel3DSelected1)</l>
<l>fit_primitives_object_model_3d (ObjectModel3DSelected1, 'primitive_type', 'all', ObjectModel3Dsphere)</l>
<c></c>
<l>get_object_model_3d_params(ObjectModel3Dsphere, 'center', SphereCenter)</l>
<c></c>
<l>GlobalOutputObjectPosition := SphereCenter</l>
<c></c>
<c>*** Step 5) Display results</c>
<l>if (localTesting)</l>
<l>    visualize_object_model_3d (200000, [ObjectModel3D, ObjectModel3Dsphere], [], [], [], [], [], [], [], PoseOut)</l>
<l>endif</l>
<c></c>
<c>*** Cleanup</c>
<l>clear_object_model_3d ([ObjectModel3D, ObjectModel3DPlane, ObjectModel3DPlaneNB, ObjectModel3DThresholded, ObjectModel3DConnected, ObjectModel3Dsphere])</l>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
